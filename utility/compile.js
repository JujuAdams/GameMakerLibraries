/**
 * @file Compile all library documentation into human-friendly files.
 */

const fs = require('fs');
const { compileFromFile } = require('json-schema-to-typescript');
const { stripIndent } = require('common-tags');
const prettier = require('prettier');
const { unique, readJSON, assert } = require('./utility.js');
const Ajv = require('ajv').default;
const addFormats = require('ajv-formats').default;

const readmePath = './README.md';
const librariesPath = './libraries.json';
const librariesSchemaPath = './utility/libraries-schema.json';
const librariesTypesPath = './utility/libraries-schema.d.ts';
const tagsPath = './tags.txt';

/**
 * @typedef {import('./libraries-schema.js').GameMakerLibraryData} Libraries
 * @typedef {import('./libraries-schema.json')} Schema
 */

async function loadAndUpdateValidator() {
  // Load the libraries schema and update it if needed
  /** @type {Schema} */
  const librariesSchema = readJSON(librariesSchemaPath);
  librariesSchema.definitions.tag.enum = unique(
    fs
      .readFileSync(tagsPath, 'utf8')
      .trim()
      .split('\n')
      .filter((x) => x)
      .sort()
  );
  // Save any changes made
  fs.writeFileSync(
    librariesSchemaPath,
    prettier.format(JSON.stringify(librariesSchema), { parser: 'json' })
  );

  // Create the validator (which will also ensure the schema is valid)
  const ajv = new Ajv();
  // Add "format" validators so we can get free/cheap validation of strings
  addFormats(ajv, ['uri', 'date']);

  /** @type {import('ajv').ValidateFunction<Schema>} */
  const validate = ajv.compile(librariesSchema);

  // Create a Typescript types file from the schema, to make it easier
  // to code with IDE support.
  const asTypescriptString = await compileFromFile(librariesSchemaPath);
  fs.writeFileSync(librariesTypesPath, asTypescriptString);

  return validate;
}

/**
 * @param {Libraries} libraries
 */
function compileReadme(libraries) {
  /**
   * The "preamble" was taken directly from the original README.md file.
   * It now includes a comment informing users who open up the README file
   * that they should not edit it directly, but should instead edit it
   * here.
   *
   * In other words, ignore that comment telling you not to edit,
   * **if you are doing your editing right here in this file**.
   *
   * @type {string}
   */
  const preamble = stripIndent(`
    <!--
      DO NOT EDIT. This file is automatically generated,
      so any manual edits will be lost. To change the README
      content, edit the \`compileReadme\` function in \`utility/compile.js\`.
    -->
    <h1 align="center">${libraries.title}</h1>

    <p align="center">${libraries.description}</p>

    <p align="center">
      Come chat about GameMaker on the <a href="https://discord.gg/8krYCqr">Discord server</a>
    </p>`);

  let markdownComponents = [
    preamble,
    '## Contributing',
    stripIndent`
      To add or edit information about a GameMaker library,
      see the [Contributing Guide](./CONTRIBUTING.md).
    `,
    '## Libraries',
    ...libraries.libraries.map((library) => {
      // NOTE: This is currently just re-creating the original markdown
      //       but it could be changed to add tags, authors, and any other
      //       information that gets added.
      return `[${library.title}](${library.url})`;
    }),
  ];
  fs.writeFileSync(readmePath, markdownComponents.join('\n\n'));
}

/**
 *
 * @param { Awaited<ReturnType<typeof loadAndUpdateValidator>>} validate
 */
function loadAndUpdateLibraries(validate) {
  // Load the library data and test it against the schema
  /** @type {Libraries} */
  const libraries = readJSON(librariesPath);
  const isValid = validate(libraries);
  if (!isValid) {
    console.error(validate.errors);
    process.exit(1);
  }
  // Check author refs to make sure they all exist
  libraries.libraries.forEach((library) => {
    library.authors?.forEach((author) => {
      if (typeof author == 'string') {
        const referencedAuthor = libraries.authors[author];
        // @ts-ignore
        assert(referencedAuthor, `Author key "${author}" not found.`);
      }
    });
  });

  // Prettify
  fs.writeFileSync(
    librariesPath,
    prettier.format(JSON.stringify(libraries), { parser: 'json' })
  );
  return libraries;
}

async function main() {
  const validate = await loadAndUpdateValidator();
  const libraries = loadAndUpdateLibraries(validate);
  compileReadme(libraries);
}

main();
